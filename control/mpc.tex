\FloatBarrier\section{MPC} \label{sec:mpc}

    \paragraph
    \gls{MPC} refers to a control approach where the control action at each time-step 
    is determined by solving an open-loop optimal control problem over a finite prediction horizon \cite{Mayne2000}.
    \gls{MPC} does not refer to a specific algorithm implementation, but rather to the general control approach.
    A specific \gls{MPC} implementation is dependant on the plant model representation \cite{Garcia1989}.
    In this section, an overview will be given of the specific \gls{MPC} implementation used in this work.
    The \gls{MPC} algorithm will be explained and the design process to tune this implementation will be discussed.
    Finally, the control response of the tuned \gls{MPC} will be shown and discussed for a simulated system.
    
    % ?? Lit study: include different types of \gls{MPC}, e.g. DMC, MAC
    % ?? different types of models \cite{}, 

    \FloatBarrier\subsection{Model}

        \paragraph
        In the proposed control architecture for a multirotor with an unknown suspended payload,
        the \gls{MPC} is used with a estimated model from the data-driven techniques discussed in Chapter~\ref{chap:system_id}.
        DMDc and HAVOKc produce discrete, linear state-space models of the system dynamics.

        MIMO
        State space
        Discrete

        MV, MO, UO, UD,
        diagram of model



    \FloatBarrier\subsection{Receding horizon}

        \paragraph
        Diagram of prediction horizon and control horizon

        \paragraph
        controller desicion, ${z_k}^T = [ u( k | k )^T ~~ u( k+1 | k)^T ~~ ... ~~ u( k+p-1 | k )^T ] $

    \FloatBarrier\subsection{Algoriithm}

        \paragraph
        Different implementations. e.g. list
        Based on model
        Other \gls{MPC} optimiser options.
        MATLAB chosen. Why MATLAB?
        C++ generation
        
        \paragraph
        The \gls{MPC} implementation from the Model Predictive Control Toolbox\texttrademark ~solves the control optimisattion problem as a \gls{QP} at each time interval \cite{MPCtoolbox2019}.
        This QP usually consists of three features, namely,
        \begin{itemize}
            \item the objective function,
            \item the constraints, and
            \item the controller desion
        \end{itemize}
        The objective function provides a scalar value that quatifies the controller performance.
        The controller desicion is the \gls{MV} adjustments determined by the QP solver that minimise the objective function.
        The constraints are conditions that the controller decision need to satisfy, such as bounds on the MO, MV, and \gls{MV} increment values.

        \paragraph
        Constraints cause non-linear ..., 
        not applied

        \paragraph
        The objective function used by the Model Predictive Control Toolbox\texttrademark is documented well by the corresponding user manual \cite{MPCtoolbox2019}.
        An overview of this implementation, which is used in this work, will be given here. 
        The objective function consists of the sum of three terms that each quantify a specific aspect of the control performance,
        and is calculated as,
        \begin{equation}
            J(z_k) = J_y(z_k) + J_u(z_k) + J_{\Delta u}(z_k),
        \end{equation}
        where $z_k$ is the controller decison at time-step $k$.
        The three scalar performance measures are denoted as
        $J_y(z_k)$ for output setpoint tracking,
        $J_u(z_k)$ for \gls{MV} tracking, and
        $J_{\delta u}(z_k)$ for \gls{MV} move suppression
        Each performance measure includes weigths that balanse the competing objectives of the different terms.
        These weights need to be manually tuned for a desired controller performance.

        \paragraph
        \textbf{Output setpoint tracking}  \newline
        The performance measure of the output setpoint tracking is calulated as,
        \begin{equation}
            J_y(z_k) = \sum_{j = 1}^{n_y} ~ \sum_{i = 1}^{N_p} 
                \left\{ 
                    {w^y}_{j} 
                        \left[ 
                            r_j( k+i | k) - y_j( k+i | k)
                        \right]
                \right\}^2 ,
        \end{equation}
        where the symbols are denoted as, \newline
        \begin{tabular}{ l l } 
            $k$             & Current control interval time-step. \\
            $n_y$           & Number of output variables. \\ 
            $N_p$           & Prediction horizon. \\ 
            $y_j( k+i | k)$ & Predicted value of $j$\textsuperscript{th} output variable at $i$\textsuperscript{th} time-step from $k$. \\
            $r_j( k+i | k)$ & Reference value of $j$\textsuperscript{th} output variable at $i$\textsuperscript{th} time-step from $k$. \\
            ${w^y}_{j}$     & Tuning weight for $j$\textsuperscript{th} output variable. \\
        \end{tabular}

        \paragraph
        The controller receives the reference values, $r_j( k+i | k)$, for the prediction horizon starting at time-step $k$.
        Using the inernal plant model, the predicted output values, $y_j( k+i | k)$, is determined based on the controller decision, $z_k$.
        The values of $N_p$ and ${w^y}_{j}$ are design choises and are constant controller specifications.
        The value of $n_y$ is also constant and is determined from the plant model.

        \paragraph
        \textbf{Manipulated variable tracking}  \newline
        In some control applications, it is desirable to keep specific \gls{MV} variables close to a target value.
        In the multirotor use case, lower \gls{MV} values are prefered because this corresponds to lower energy use.
        The \gls{MV} target values are therefore set to zero for our use case. 
        The performance measure of the manipulated variable tracking is calculated as,
        \begin{equation}
            J_u(z_k) = \sum_{j = 1}^{n_u} ~ \sum_{i = 0}^{N_p - 1} 
                \left\{ 
                    {w^u}_{j} 
                        \left[ 
                            u_j( k+i | k) - u_{j,sp}( k+i | k)
                        \right]
                \right\}^2 ,
        \end{equation}
        where the symbols are denoted as, \newline
        \begin{tabular}{ l l } 
            $n_u$           & Number of manipulated variables. \\ 
            $u_j( k+i | k)$ & Control decision of $j$\textsuperscript{th} \gls{MV} at $i$\textsuperscript{th} time-step from $k$. \\
            $u_{j,target}( k+i | k)$ & Target value of $j$\textsuperscript{th} \gls{MV} at $i$\textsuperscript{th} time-step from $k$. \\
            ${w^u}_{j}$   & Tuning weight for $j$\textsuperscript{th} \gls{MV}. \\
        \end{tabular}

        \paragraph
        The desired $u_{j,target}( k+i | k)$ values can be received for the prediction horizon starting at time-step $k$.
        However, for our use case, all $u_{j,target}( k+i | k)$ values are constant and zero.
        The value of $n_u$ is fixed by the plant model.
        The ${w^u}_{j}$ values are also constant and are determined as a design choise.
        
        \paragraph
        \textbf{Manipulated variable increment suppression}  \newline
        Large increments or moves in the \gls{MV} values is often undesirable for good control performance.
        In the multirotor use case, large increments of the acceleration \gls{MV}s result in large jerks which may cause the system to go beyond the accurate vector subspace of the plant model.
        High frequency moves in the acceleration \gls{MV}s may also cause jittery flight dynamics because acceleration setpoint changes correspond to attidue changes.
        The performance measure of \gls{MV} tracking is used to penalise increments in the \gls{MV}s.
        This is calulated as,
        \begin{equation}
            J_\Delta u (z_k) = \sum_{j = 1}^{n_u} ~ \sum_{i = 0}^{N_p - 1} 
                \left\{ 
                    {w^{\Delta u}}_{j} 
                        \left[ 
                            u_j( k+i | k) - u_j( k+i-1 | k)
                        \right]
                \right\}^2 ,
        \end{equation}
        where the symbols are denoted as, \newline
        \begin{tabular}{ l l } 
            ${w^u}_{j}$   & Tuning weight for movement in the $j$\textsuperscript{th} \gls{MV}. \\
        \end{tabular}

        \paragraph
        The values of ${w^{\Delta u}}_{j}$ are constant and are determined as a design choise.

        \paragraph
        The similarities and differences between the \gls{LQR} and \gls{MPC} objective functions should be noted.
        The \gls{LQR} implementation described in Section~\ref{sec:lqr}, did not included penalisation for MV increments.
        However, if $J_\Delta u (z_k)$ is removed from the objective function, the \gls{MPC} and \gls{LQR} controllers optimise the same variables.
        In both implementations weights are designed for these variables in the objective function.

        \paragraph
        The \gls{LQR} optimisation corresponds to solving the unconstrained \gls{MPC} optimisation problem for $N_p = \infty$.
        However, the \gls{LQR} optimisation is run only once to determine the \gls{LQR} gain, whereas the \gls{MPC} optimisation is re-run at every time-step.
        Also note that the \gls{LQR} uses a continuous-time model, but the \gls{MPC} considered in this work uses a discrete-time model.

% ?? convert acronyms to \gls{}

    \FloatBarrier\subsection{Integral action}
        
        \paragraph
        A simple implementation of predictive control with multiple \gls{OV}s does not inherantly apply integral action or disturbance rejection.
        For the multirotor and suspeneded payload use case,
        \gls{MPC} control without integral action results in a non-zero steady-state error of the mulrtirotor velocity, due to wind distrubance and inaccuracies in modelling the drag.
        % Due to modelling inaccuraciose or disturbances, 
        % the \gls{MPC} may continually determine and execute a control action that does not drive the the If the actual aerodynamics drag is more than the drag accounted for in the model.
        % In this case, zero steady-state error tracking for every OV will not be achieved in the presence of any model inaccuracy or disturbance.
        
        % A example can be used to explain this with the multirotor system.
        % Consider the case when the multirotor is flying at steady-state velocity and the payload angle is at steady-state.
        % The \gls{MPC} controls both the multirotor velocity and the payload angle.
        % A new velocity setpoint is given that is slightly large than the current velocity.
        % The \gls{MPC} optimiser will genertae a solution, $z_k$, to accelerate slowly to the new velocity setpoint without disturbing the paylaod angle too much. 
        
        \paragraph
        Different methods have been proposed to apply integral action with an \gls{MPC}.
        A commonly used method involves applying an integrator to the control action determined by the \gls{MPC} \cite{Ruscio2013}.
        In this implementation, the \gls{MPC} detemines the optimal control action increment, ${\Delta u_k}^*$,
        and the control action, $u_k = u_{k-1} + {\Delta u_k}^*$ is applied.
        Hence, ingtegral action is applied to the plant input.
        This method is also discribed by \cite{Mayne2000}.

        \paragraph
        Another commonly used strategy involves estimating a constant disturbance in the plant model which influences an \gls{OV} \cite{Ruscio2013}.


    \FloatBarrier\subsection{Tuning}

        \paragraph
        In the controller tuning process, a large value of ${w^y}_{j}$ will correspond to more agrresive maneuvers of the $j$\textsuperscript{th} \gls{OV}, because of the tracking error of that \gls{OV} will be heavily penalised.
        For the tuning process, small values of ${w^u}_{j}$, correspond to aggresive maneuvers, because the values of the \gls{MV}s are not heavily penalised in the objective function. 

        \paragraph
        The value of $N_p$ determines the number of decision values in $z_k$.
        Therefore the computational complexity of the QP problem increases with larger values of $N_p$.
        However, if the 
        Hence, the value of $N_p$ needs
        It is often state as a 

    \input{control/plots/mpc_tuning_plot.tex}