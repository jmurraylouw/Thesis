\graphicspath{{system_id/fig/}}

\chapter{System identification}
\label{chap:system_id}

    \paragraph{}
    System identification is the process of creating mathematical models of a dynamical system by using input and output measurements of that system.
    Two major approaches are used to represent the dynamics of such a system:
    \begin{enumerate}
        \item A priori mathematical modelling with parameter estimation
        \item Data-driven system identification
    \end{enumerate}

    Models determined from a priori modelling and parameter estimation are referred to as white-box models.
    In contrast, data-driven system identification methods result in black-box models.
    This chapter discusses these system identification approaches and describes the differences between them.
    For each approach, different estimation techniques are explained and applied to the quadrotor and payload system.
    The results of these techniques are then compared to each other.    

\section{White-box and black-box techniques}

    \subsection{White-box techniques}

        \paragraph{} 
        The underlying physics of a white-box model is understood by the user because    
        they are determined from first principles.
        This is done by modelling physical processes with techniques like Lagrangian mechanics or Newton equations.
        With system identification techniques that use these models, 
        the mathematical relations between system parameters are predefined in the modelling phase.
        The system identification process is therefore reduced to parameter estimation to determine values for parameters used in die model.

        \paragraph{} 
        This approach is used by \cite{Erasmus2020} and \cite{Slabber2020} for swing damping control of a quadrotor with an unknown suspended payload.
        The system was modelled as two rigid bodies connected by a link and the following assumptions were made regarding the suspended payload:
        \begin{itemize}
            \item The payload is a point mass.
            \item The link is massless.
            \item The link is rigid.
            \item The link is attached to the CoM of the quadrotor.
        \end{itemize}
        The only unknown parameters in the quadrotor and payload model is the payload mass and link length.
        These parameters are first estimated and then inserted into the predefined, linearised model.
        This model is used by a LQR controller to damp swing angles while also controlling the vehicle.

        \paragraph{} 
        The approach works well for systems with predictable dynamics, but it is not very adaptable.
        The payload considered by \cite{Erasmus2020} and \cite{Slabber2020} is limited to a small rigid mass suspended from the quadrotor by a non-stretching cable. 
        In this use case it was shown that a LQR controller successfully controls a quadrotor while minimising payload swing angles.
        However, if a payload or cable is used that violates one of the modelling assumptions, the predefined model no longer accurately represent the system.
        Since the controller is dependent on this model, the mismatch between the model and actual dynamics may result in undesirable controller behaviour.

    \subsection{Black-box techniques}

        Data-driven system identification methods produce black-box models.
        In contrast to white-box models, black-box models do not require predefined mathematical relations between system parameters.
        % The user only considers what goes into, and comes out of, the black-box.
        % Something imagery about why it is called black box
        No prior knowledge of the physics of the system are considered and no modelling assumptions are made.
        Black-box techniques determine the mathematical relationship between inputs and outputs of a system using information from measurement data only.

        \paragraph{}
        Black-box models can be categorised as either non-linear or linear models.
        Non-linear models are often more accurate than linear models because complex, real-world dynamics are better approximated by non-linear systems.
        The dynamics of a quadrotor and suspended payload are also non-linear.
        Examples of black box models with quadrotors and payloads in literature ???

        \paragraph{}
        However, non-linear models are inherently more complex than linear models. 
        Controllers that use non-linear models are usually more computationally complex than those with linear models.
        Control archetictures for quadrotors used in practical applications are mostly implemented on onboard hardware.
        Therefore there is value in low-complexity, linear models since these may be simple enough to execute on low cost hardware.
        trade-off between accuracy and complexity.
        Non-linear models may require control implementations that are too computationally expensive and may not be practically realisable on the available hardware on a quadrotor.
        
        \paragraph{}
        DMDc and HAVOK are the two data-driven system identification methods investigated in this paper. 
        These are linear regression techniques that produce a linear model to approximate non-linear dynamics.
        Non-linear data-driven techniques like Neural Networks and SINDy \cite{Brunton2016} may produce models that are more accurate than linear techniques, 
        but at the cost of greater computational complexity.
        \murray{Name more techniques}
        DMDc and HAVOK are less computationally complex and their models are suitable for linear MPC, which is significantly faster than non-linear MPC.
        This is desirable for a RUAV use case, where onboard computational power is limited.
        
        \paragraph{}
        These techniques and their implementation are explained in the sections below.
        Each technique is considered for use in a velocity controller in the North direction

    
\section{Parameter estimation}
    \subsection{Payload mass estimation}
        RLS

    \subsection{Cable length estimation}
        The cable length is estimated from the measurement of natural frequency of the swinging payload.
        As described by
        \cite{bisgaard},
        the natural frequency is given by:
        \begin{equation} \label{eq:nat_freq}
            \omega_n = \sqrt{ \frac{g}{l} \cdot \frac{m_q + m_p}{m_q}}
        \end{equation}
        The natural frequency is measured by performing a FFT on the payload swing angle response after a position step by the quadrotor.
        The dominant frequency identified by the FFT during free swing is the natural frequency of the payload.
        
        \ref{fig:pos_step_angle}
        shows the payload swing angle after the system is stimulated by a position step setpoint.
        As shown in 
        \ref{fig:pos_step_angle}
        the first few seconds of the step response are not used in the FFT.
        This is to minimise the effect of the quadrotor controllers on the swing angle frequency 
        by excluding the transient response in the FFT.

        \ref{fig:fft} 
        shows the resulting amplitude spectrum of the payload swing angle response.
        The dominant frequency is clearly identified as ??.
        Since $m_q$ and $g$ is known, and $m_p$ and $\omega_n$ has been estimated, $l$ can now be determined from
        \ref{eq:nat_freq}.
        In this case the estimated length is ??, compared to the actual length of ??.
        
        Frequency resolution ??
        error for different lengths??
  
\section{Dynamic Mode Decomposition with control}
\label{sec:dmdc}        

    \murray{remember to cite CCA paper if published}
    
    \paragraph{Intro}        
    DMD is a linear regression technique that can be used to approximate a non-linear dynamical system \cite{Tu2014}.
    It uses temporal measurements of system outputs to reconstruct system dynamics without prior modelling assumptions.
    DMDc is an adaptation of DMD that also accounts for control inputs \cite{Proctor2016c}.
    This section provides an overview of the specific implementation of DMDc used in this paper.        
    Note that this implementation is a slight adaptation of DMDc, and includes time-delay-embedding of multiple observables. 
    \cite{Korda2018b} and \cite{Arbabi2018} use time-delay-embedding in their DMD adaptions in similar ways.

    \paragraph{Considered controller}
    % As discussed in \ref{sec:linear_model}, the payload has minimal effect on quadrotor attitude because it is attached near the CoM of the vehicle.
    % Therefore the attitude states are excluded from the system identification model.
    The model identified by DMDc will be used to design a longitudinal velocity controller.
    As shown in \ref{fig:system_id_plant}, the plant considered for system identification includes the dynamics of the inner loop, attitude controllers.
    The swing damping controllers which will utilise the identified model act only in the translational velocity loop.
    Because of the large time-scale separation between the inner and outer loop controllers, 
    the attitude states have a negilable effect on the plant dynamics seen by the velocity controller.
    As discussed in Section~\ref{sec:linear_model}, the payload minimally effects the quadrotor attitude because it is attached near the CoM of the vehicle.
    Therefore the attitude states are excluded from the system identification model.

    \begin{figure}[h]
        \centering
    %     \includegraphics[width=\linewidth]{cae_siamese}
        \includegraphics[width=0.5\linewidth]{floating_pend.png}            
        \caption{Floating pendulum model considered for system identification for a North velocity controller}
        \label{fig:floating_pend}
    \end{figure}

    \paragraph{Derived model}
    Figure \ref{fig:floating_pend} shows the resulting model considered for system identification.
    In Chapter \ref{chap:modelling} the differential equations that describe the motion of this system are derived with Lagrangian mechanics.
    From these equations it is clear that the considered plant is defined by the state vector,
    \begin{equation}
        \bm{x} = \begin{bmatrix}
            V_N & \dot{\theta}
        \end{bmatrix}^T,
    \end{equation}
    and the input vector,
    \begin{equation}
        \bm{u} = \begin{bmatrix}
            A_{N,sp}
        \end{bmatrix},
    \end{equation}

    % From this derivation it is clear that the angular velocity of the payload, $\dot{\theta}$, is required to described the system dynamics.
    % However, $\dot{\theta}$ is not measured directly on the considered practical quadrotor setup.
    % Instead, the payload angle, $\theta$, is measured by a potentiometer attached to a DAC on Honeybee as described in Chapter \ref{chap:system_overview}.
    % As expected, this measurement is extremely noisy.
    % \murray{Maybe insert figure to show noise}
    % % Figure \ref{} shows the angle measurement during a practical experiment of the payload while Honeybee is held stationary
    % Numerical differentiation is applied to the noisy $\theta$ signal which results in a very inaccurate estimation of $\dot{\theta}$.
    % Therefore it is desirable to rather use $\theta$ in the system identification process.

    \paragraph{State space model}
    DMD produces a linear, discrete state-space model of the system dynamics.
    Discrete measurements, $\bm{x}_k$, of the continuous time observable, $\bm{x}(t)$, are used, 
    where $\bm{x}_k = \bm{x}(k T_s)$, and $T_s$ is the sampling time of the model.    
    Delay-coordinates (i.e. $\bm{x}_{k-1}, \bm{x}_{k-2}$, etc.) are also included in the state-space model to
    account for input delay and state delay in the system.
    Input delay refers to the time delay involved with transporting a control signal to a system, 
    whereas state delay refers to time-separated interactions between system variables \cite{Chen1999}.
    Hence, we define an state delay vector as:
    \begin{equation}
        \bm{d}_{k} = 
        \begin{bmatrix}
            \bm{x}_{k-1} & \bm{x}_{k-2} & \cdots & \bm{x}_{k-q}
        \end{bmatrix}^T ,
    \end{equation}
    $\bm{d}_k \in \R^{(n_x)(q)}$ and where $q$ is the number of delay-coordinates used in the model.
    
    \paragraph{}
    The discrete state-space model is therefore defined as:
    \begin{equation} \label{eq:dmd_state_space}
        \bm{x}_{k+1} = \bm{A} \bm{x}_k + \bm{A}_d \bm{d}_k + \bm{B} \bm{u}_k ,
    \end{equation}
    \( \bm{A} \in \R^{n_x \times n_x} \) is the system matrix, 
    \( \bm{A}_1 \in \R^{(q \cdot n_x) \times (q \cdot n_x)} \) is the state delay system matrix and 
    \( \bm{B} \in \R^{n_x \times n_u} \) is the input matrix.
    
    \paragraph{Training data}
    The training data consists of full-state measurements, $\bm{x}_k$, and corresponding inputs, $\bm{u}_k$, 
    taken at regular intervals of $\Delta t = T_s$, during a simulated flight with Cascaded PID control.
    In a practical flight, these time-series measurements need to be saved in memory because it is usd as a single batch by DMD.
    Note that DMD can be applied in a recursive manner as described in \cite{Noack2016}, 
    However this implementation is not considered because memory size will not be a limitation since a companion computer will be used.
    
    \paragraph{Steps and intervals}
    For the training period, different velocity step inputs are commanded with varying time intervals between step commands.
    A algorithm schedules these velocity step commands, by assigning random step values and time-intervals within a specified range.
    The velocity range is determined in simulation by iteratively increasing the maximum velocity step 
    to a safe value where the quadrotor and payload system remain in stable flight.
    The maximum time-interval is set to a value that allows the payload swing to reach a steady-state condition.
    This ensures that the identified model includes transient and steady-state dynamics.

    \paragraph{Why velocity steps?}
    Velocity step commands are used in the training period because this 
    Frequency decomposition stimulates the system for a large range of frequencies.
    
    \paragraph{Data matrices}
    The training data is collected into the following matrices:
    \begin{align} \label{eq:dmd_matrices}
        \bm{X^\prime} = & \phantom{.} \left [
            \begin{array}{*{5}{@{}M{\mycolwd}@{}}}
                    \bm{x}_{q+2} & \bm{x}_{q+3} & \bm{x}_{q+4} & \cdots & \bm{x}_{w+q+1}
            \end{array}
        \right ] , \nonumber \\
        %
        \bm{X} \phantom{''} = & \phantom{.} \left [
            \begin{array}{*{5}{@{}M{\mycolwd}@{}}}
                \bm{x}_{q+1} & \bm{x}_{q+2} & \bm{x}_{q+3} & \cdots & \bm{x}_{w+q}                      
            \end{array}
        \right ] , \nonumber \\
        % 
        \bm{X}_d \phantom{'} = & \phantom{'} \left [
            \begin{array}{*{5}{@{}M{\mycolwd}@{}}}
                \bm{x}_{q} & \bm{x}_{q+1} & \bm{x}_{q+2} & \cdots & \bm{x}_{w+q-1} \\
                \vdots   & \vdots   & \vdots   & \ddots & \vdots \\
                \bm{x}_2 & \bm{x}_3 & \bm{x}_4 & \cdots & \bm{x}_{w+1} \\
                \bm{x}_1 & \bm{x}_2 & \bm{x}_3 & \cdots & \bm{x}_{w} \\                       
            \end{array}
        \right ] , \nonumber \\
        % 
        \bm{\Upsilon} \phantom{'} = & \phantom{.} \left [
            \begin{array}{*{5}{@{}M{\mycolwd}@{}}}
                    \bm{u}_{q} & \bm{u}_{q+1} & \bm{u}_{q+2} & \cdots & \bm{u}_{w+q-1}
            \end{array}
        \right ] ,
    \end{align}

    where $w$ is the number of columns in the matrices, 
    $\bm{X^\prime}$ is the matrix $\bm{X}$ shifted forward by one time-step, 
    $\bm{X}_d$ is the matrix with delay states, 
    and $\bm{\Upsilon}$ is the matrix of inputs.
    Equation (\ref{eq:dmd_state_space}) can be combined with the matrices in Equation (\ref{eq:dmd_matrices}) to produce:
    \begin{equation}
        \bm{X^\prime} = \bm{A} \bm{X} + \bm{A}_d \bm{X}_d + \bm{B} \bm{\Upsilon} .
    \end{equation}
    Note that the primary objective of DMDc is to determine the best fit model matrices, $\bm{A}$, $\bm{A}_d$ and $\bm{B}$, 
    given the data in $\bm{X^\prime}$, $\bm{X}$, $\bm{X}_d$, and $\bm{\Upsilon}$ \cite{Proctor2016c}.
    In order to group the unknowns into a single matrix, (\ref{eq:dmd_state_space}) is manipulated into the form,
    \begin{equation} \label{eq:G_Omega}
        \bm{X^\prime} =   
        \begin{bmatrix} 
            \bm{A} & \bm{A}_d & \bm{B} 
        \end{bmatrix}
        \begin{bmatrix} 
            \bm{X} \\ \bm{X}_d \\ \bm{\Upsilon} 
        \end{bmatrix} 
        = \bm{G \Omega} ,
    \end{equation} 
    where $\bm{\Omega}$ contains the state and control data, and $\bm{G}$ represents the system and input matrices.
    
    \paragraph{SVD}
    A SVD is performed on $\bm{\Omega}$ resulting in:
    \(
        \bm{\Omega} = \bm{U} \bm{\Sigma} \bm{V}^T
    \).
    Often, only the first $p$ columns of $\bm{U}$ and $\bm{V}$ are required for a good approximation of the dynamics \cite{Brunton2017a}.
    In many cases, the truncated form results in better models than the exact form when noisy measurements are used.
    This is because the effect of measurement noise is mostly captured by the truncated columns of $\bm{U}$ and $\bm{V}$.
    By truncating these columns, the influence of noise in the regression problem is reduced. \murray{explain this better}
    hence the SVD is used in the truncated form: 
    \begin{equation} \label{eq:tilde_svd}
        \bm{\Omega} \approx \Tilde{\bm{U}} \Tilde{\bm{\Sigma}} \Tilde{\bm{V}}^T ,
    \end{equation}
    where $\phantom{.} \Tilde{ } \phantom{.}$ represents rank-$p$ truncation.
    \murray{maybe insert colour pictures showing matrices}        

    \paragraph{}
    By combining (\ref{eq:tilde_svd}) with the over-constrained equality in (\ref{eq:G_Omega}), 
    the least-squared solution, $\bm{G}$, can be found with:
    \begin{equation}
        \bm{G} \approx \bm{X^\prime} \Tilde{\bm{V}} \Tilde{\bm{\Sigma}}^{-1} \Tilde{\bm{U}} .
    \end{equation}
    By reversing \ref{eq:G_Omega}, $\bm{G}$ can now be separated into:
    \(
        \bm{G} = \begin{bmatrix} \bm{A} & \bm{A}_d & \bm{B} \end{bmatrix}.
    \)
    according to the required dimensions of each matrix.
    Thereby, the state-space model approximated by DMDc is complete.
    
\section{Hankel Alternative View Of Koopman}
    
    \murray{q = number of delays, from here up}
    
    \paragraph{}
    HAVOK is a data-driven, regression technique that provides a connection between DMD and Koopman operator theory \cite{Brunton2017a, Champion2019}. 
    We have adapted the standard HAVOK algorithm slightly to account for the effect of control and to extract a discrete, linear model that approximates the behaviour of a controlled dynamical system.
    In this section, a brief overview is provided for this implementation and expansion of \mbox{HAVOK}.
    % 
    \paragraph{}
    The extracted discrete state-space model is defined as:
    \begin{equation} \label{eq:havoc_state_space}
        \bm{a}_{k+1} = \Tilde{\bm{A}} \bm{a}_k + \Tilde{\bm{B}} \bm{u}_k ,
    \end{equation}
    where $\bm{a}_k$ is the state vector previously defined in Section \ref{sec:dmdc}, 
    \( \Tilde{\bm{A}} \in \R^{(q \cdot n_x) \times (q \cdot n_x)} \) is the system matrix, 
    and \( \Tilde{\bm{B}} \in \R^{(q \cdot n_x) \times n_u} \) is the input matrix. 
    Here, $\Tilde{\phantom{a}}$ is used to differentiate these matrices from $\bm{A}$ and $\bm{B}$ used in DMDc.
    % 
    \paragraph{}
    The original HAVOK algorithm, developed by \cite{Brunton2017}, constructs a Hankel matrix from output variables only. 
    In order to incorporate the effect of control, an extended Hankel matrix, $\bm{\Pi}$, is created by appending a matrix of inputs to a Hankel matrix of measurements:
    \begin{equation} \label{eq:pi_hankel}
        \bm{\Pi} = \phantom{.} \left [
            \begin{array}{*{5}{@{}M{\mycolwd}@{}}}
                    \bm{a}_{q} & \bm{a}_{q+1} & \bm{a}_{q+2} & \cdots & \bm{a}_{w+q-1} \\
                    \bm{u}_{q} & \bm{u}_{q+1} & \bm{u}_{q+2} & \cdots & \bm{u}_{w+q-1}
            \end{array}
        \right ] ,
    \end{equation}
    where $w$ is the number of columns in $\bm{\Pi}$.
    A truncated SVD of this Hankel matrix results in following approximation:
    \begin{equation} \label{eq:havok_svd_tilde}
        \bm{\Pi} \approx \Tilde{\bm{U}} \Tilde{\bm{\Sigma}} \Tilde{\bm{V}}^T ,
    \end{equation}
    where $\Tilde{\phantom{a}}$ represents rank-$p$ truncation.
    It is important to note that the model extracted by HAVOK depends on the choice of hyperparameters, $p$ and $q$.
    The number of samples in the training data, $N_{train} = w + q -1$, also influences the accuracy of the model.
    % 
    \paragraph{}
    The columns of $\Tilde{\bm{V}}$ are the most significant principal components of the system dynamics \cite{Kamb2020}.
    This matrix, $\Tilde{\bm{V}}$, can be considered to contain a time-series of the pseudo-state, $\bm{v}$, such that
    \(
        \Tilde{\bm{V}}^T = \begin{bmatrix} 
            \bm{v}_q & \bm{v}_{q+1} & \cdots & \bm{v}_w 
        \end{bmatrix} ,
    \)
    characterises the evolution of the actual dynamics in an eigen-time-delay coordinate system \cite{Brunton2017}.
    % 
    Consider the following discrete, state-space formulation:
    \begin{equation} \label{eq:v_ss}
        \bm{v}_{k+1} = \bm{\Lambda} \bm{v}_k .
    \end{equation}
    Recall that DMDc finds a best fit linear operator that directly maps $\bm{a}_{k}$ to $\bm{a}_{k+1}$.
    Similarly, HAVOK determines the best fit linear operator $\bm{\Lambda}$ that maps the pseudo-state $\bm{v}_k$ to $\bm{v}_{k+1}$.
    So, in order to setup an over-determined equality for (\ref{eq:v_ss}), $\Tilde{\bm{V}}^T$ is divided into two matrices:
    \begin{align} \label{eq:v1v2}
        \bm{V}_1 &= \left [
            \begin{array}{*{5}{@{}M{\mycolwd}@{}}} 
                \bm{v}_{q \phantom{-1}}     & \bm{v}_{q+1} & ... & \bm{v}_{w-1} \\
            \end{array} 
        \right ] , \nonumber \\ 
        \bm{V}_2 &= \left [
            \begin{array}{*{5}{@{}M{\mycolwd}@{}}} 
                \bm{v}_{q+1}     & \bm{v}_{q+2} & ... & \bm{v}_{w \phantom{-1}} \\
            \end{array} 
        \right ] ,
    \end{align} 
    where $\bm{V}_2$ is $\bm{V}_1$ advanced a single step forward in time.
    The matrices from Equation (\ref{eq:v1v2}) are now combined with Equation (\ref{eq:v_ss}) and the best fit $\bm{\Lambda}$ is determined with the Moore-Penrose pseudoinverse:
    \begin{equation} \label{eq:v_dmd}
        \bm{V}_2 = \bm{\Lambda} \bm{V}_1 \phantom{---} \Rightarrow \phantom{---} \bm{\Lambda} \approx \bm{V}_1 \bm{V}_1^{\dagger}
    \end{equation}
    % 
    It can be shown from Equation (\ref{eq:havok_svd_tilde}) that Equation (\ref{eq:v_ss}) is transformed from the eigen-time-delay coordinate system to the original coordinate system as the following:
    \begin{equation} \label{eq:v_ss_a} 
        \begin{bmatrix}
            \bm{a}_{k+1}  \\  \bm{u}_{k+1} 
        \end{bmatrix}
    \phantom{.} = \phantom{.} (\Tilde{\bm{U}} \Tilde{\bm{\Sigma}}) \bm{\Lambda} (\Tilde{\bm{U}}  \Tilde{\bm{\Sigma}})^{\dagger} \phantom{.}
        \begin{bmatrix}
            \bm{a}_{k}  \\  \bm{u}_{k} 
        \end{bmatrix} .
    \end{equation}    
    % 
    This form is used to extract $\Tilde{\bm{A}}$ and $\Tilde{\bm{B}}$ from the matrix,
    \( 
        (\Tilde{\bm{U}} \Tilde{\bm{\Sigma}}) \bm{\Lambda} (\Tilde{\bm{U}}  \Tilde{\bm{\Sigma}})^{\dagger}
    \), in the following way:
    \begin{equation} \label{matrix_decomp}
        \begin{bmatrix}
            \bm{a}_{k+1}  \\  \bm{u}_{k+1} 
        \end{bmatrix}
        \phantom{.} = \phantom{.} 
        \begin{bmatrix}
            \Tilde{\bm{A}} \phantom{.....} \Tilde{\bm{B}} \\
            \textit{(discarded)}
        \end{bmatrix}
        \phantom{.}
        \begin{bmatrix}
            \bm{a}_{k}  \\  \bm{u}_{k} 
        \end{bmatrix}.
    \end{equation}    
    % 
    % This decomposition is illustrated in Fig.~\ref{fig:lambda_decomp}, where blocks represent different groups of entries in the matrix.
    % \begin{figure}[h]
    %     \includegraphics[scale = 0.45]{Lambda_decomp.png}
    %     \centering
    %     \caption{Illustration of the extraction of $\Tilde{\bm{A}}$ and $\Tilde{\bm{B}}$ from (\ref{eq:v_ss_a})}
    %     \label{fig:lambda_decomp}
    % \end{figure}
    % 
    Note that the matrix entries in (\ref{matrix_decomp}) that map $\bm{u}_k$ to $\bm{u}_{k+1}$ are meaningless for our purposes and are discarded.
    Similarly to DMDc, some matrix entries in $\Tilde{\bm{A}}$ and $\Tilde{\bm{B}}$ are known a priori due to the relative positions of delay coordinates. These are forced to 1 or 0 to improve the prediction performance of the model.
    
    \murray{merge these paragraphs}
    Since the state vector, $\bm{a}$, includes delay-coordinates, some matrix entries are known a priori and are independent of the dynamics. 
    For example, the values of $\bm{x}_{k}$ should be mapped from their position in $\bm{a}_k$ to specific indices in $\bm{a}_{k+1}$. 
    Due to the least-squares fitting and coordinate transformation, DMDc will not produce these exact values in $\bm{A}$ and $\bm{B}$. 
    By forcing each of these matrix entries to 1 or 0, the state-prediction performance of the model is improved.




\section{Implentation and results}
    \subsection{Methodology}

        \begin{enumerate}
            \item Takeoff and hover
            \item Command a series of velocity step inputs with random step sizes and time intervals
            \item Measure and save input and output data
            \item Apply algorithm to data and generate model
        \end{enumerate}
    
    \subsection{Effect of sample time}
    \subsection{Effect of hyperparameters and size of data}
    \subsection{Dynamic payload}
    \subsection{Practical flight data}
    \subsection{HIL}
        \paragraph{Companion computer}
        \paragraph{Software}
        \paragraph{CPU}
        \paragraph{Memory}

